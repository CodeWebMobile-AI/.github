name: Claude Command Handler
on:
  issue_comment:
    types: [created]

jobs:
  process-command:
    if: |
      github.event.issue.labels[*].name contains 'project-suggestions' &&
      contains(github.event.comment.body, '@claude create')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: Install Dependencies
        run: |
          pip install anthropic pygithub requests pyyaml beautifulsoup4
          
      - name: Process Admin Command
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.CLAUDE_PAT }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          python3 << 'EOF'
          import os
          import re
          import json
          from github import Github
          from claude_brain_projects import ProjectCreator
          
          class CommandProcessor:
              def __init__(self):
                  self.g = Github(os.environ['GITHUB_TOKEN'])
                  self.org = self.g.get_organization('CodeWebMobile-AI')
                  self.issue_number = int(os.environ['ISSUE_NUMBER'])
                  self.comment_body = os.environ['COMMENT_BODY']
                  self.issue_body = os.environ['ISSUE_BODY']
                  self.creator = ProjectCreator()
                  
              def parse_command(self):
                  """Parse the admin command"""
                  command_match = re.search(r'@claude create\s+(.+)', self.comment_body.lower())
                  if not command_match:
                      return None
                      
                  command_arg = command_match.group(1).strip()
                  
                  if command_arg == 'all':
                      return {'type': 'all'}
                  elif '+' in command_arg:
                      # e.g., "8+" means score 8 or above
                      score = int(command_arg.replace('+', ''))
                      return {'type': 'score', 'min_score': score}
                  else:
                      # Specific numbers, e.g., "1,3,5"
                      numbers = [int(n.strip()) for n in command_arg.split(',')]
                      return {'type': 'specific', 'numbers': numbers}
              
              def extract_projects_from_issue(self):
                  """Extract project suggestions from the issue body"""
                  projects = []
                  
                  # Parse each project section
                  project_pattern = r'### (\d+)\. (.+?) [üü¢üü°üî¥] \(Score: (\d+)/10\)'
                  matches = re.finditer(project_pattern, self.issue_body)
                  
                  for match in matches:
                      number = int(match.group(1))
                      name = match.group(2)
                      score = int(match.group(3))
                      
                      # Extract project details
                      project_section = self.issue_body[match.end():]
                      next_project = re.search(r'### \d+\.', project_section)
                      if next_project:
                          project_section = project_section[:next_project.start()]
                      
                      # Parse project details
                      type_match = re.search(r'\*\*Type\*\*: (.+)', project_section)
                      desc_match = re.search(r'\*\*Description\*\*: (.+)', project_section)
                      tech_match = re.search(r'\*\*Tech Stack\*\*: (.+)', project_section)
                      
                      project = {
                          'number': number,
                          'name': name,
                          'score': score,
                          'type': type_match.group(1) if type_match else 'webapp',
                          'description': desc_match.group(1) if desc_match else '',
                          'tech_stack': [t.strip() for t in tech_match.group(1).split(',')] if tech_match else []
                      }
                      
                      projects.append(project)
                  
                  return projects
              
              def execute_command(self):
                  """Execute the admin command"""
                  command = self.parse_command()
                  if not command:
                      self.post_error_comment("Invalid command format. Use: @claude create 1,3,5 | all | 8+")
                      return
                  
                  # Get all projects from the issue
                  all_projects = self.extract_projects_from_issue()
                  
                  # Filter projects based on command
                  selected_projects = []
                  
                  if command['type'] == 'all':
                      selected_projects = all_projects
                  elif command['type'] == 'score':
                      selected_projects = [p for p in all_projects if p['score'] >= command['min_score']]
                  elif command['type'] == 'specific':
                      selected_projects = [p for p in all_projects if p['number'] in command['numbers']]
                  
                  if not selected_projects:
                      self.post_error_comment("No projects matched your selection criteria.")
                      return
                  
                  # Create selected projects
                  created_repos = []
                  failed_projects = []
                  
                  self.post_comment(f"üöÄ Creating {len(selected_projects)} selected projects...")
                  
                  for project in selected_projects:
                      try:
                          print(f"Creating project: {project['name']}")
                          repo = self.creator.create_complete_project(project)
                          if repo:
                              created_repos.append({
                                  'name': project['name'],
                                  'url': repo.html_url
                              })
                      except Exception as e:
                          print(f"Failed to create {project['name']}: {e}")
                          failed_projects.append({
                              'name': project['name'],
                              'error': str(e)
                          })
                  
                  # Post results
                  self.post_results_comment(created_repos, failed_projects)
                  
                  # Close issue if all successful
                  if created_repos and not failed_projects:
                      issue = self.g.get_repo(f"{self.org.login}/.github").get_issue(self.issue_number)
                      issue.edit(state='closed')
              
              def post_comment(self, message):
                  """Post a comment on the issue"""
                  repo = self.g.get_repo(f"{self.org.login}/.github")
                  issue = repo.get_issue(self.issue_number)
                  issue.create_comment(message)
              
              def post_error_comment(self, error):
                  """Post an error comment"""
                  self.post_comment(f"‚ùå **Error**: {error}")
              
              def post_results_comment(self, created, failed):
                  """Post results of project creation"""
                  message = "## üìä Project Creation Results\n\n"
                  
                  if created:
                      message += "### ‚úÖ Successfully Created\n\n"
                      for repo in created:
                          message += f"- [{repo['name']}]({repo['url']})\n"
                  
                  if failed:
                      message += "\n### ‚ùå Failed to Create\n\n"
                      for project in failed:
                          message += f"- {project['name']}: {project['error']}\n"
                  
                  if created and not failed:
                      message += "\n‚ú® All projects created successfully! This issue has been closed."
                  
                  self.post_comment(message)
          
          # Execute
          processor = CommandProcessor()
          processor.execute_command()
          EOF
          
      - name: Add Reaction
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CLAUDE_PAT }}
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            })
            
      - name: Add Error Reaction
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CLAUDE_PAT }}
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'confused'
            })
